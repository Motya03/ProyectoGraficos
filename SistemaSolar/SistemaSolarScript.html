<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Selector de Shaders: Toon vs Niebla</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }

        canvas {
            border: 2px solid #333;
            background-color: #262626;
        }

        .controls {
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            margin: 0 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2E7D32;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
    </style>


    <script id="myVertexShader" type="x-shader/x-vertex">#version 300 es
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;

    in vec3 VertexPosition;
    in vec3 VertexNormal;

    out vec3 vNormal;
    out vec3 vPos;       // View Space Position (for lighting)
    out vec3 vLocalPos;  // Object Space Position (for texturing)

    void main() {
        vNormal = normalize(normalMatrix * VertexNormal);
        vec4 ecPosition = modelViewMatrix * vec4(VertexPosition, 1.0);
        vPos = vec3(ecPosition);
        vLocalPos = VertexPosition; // Pass original position
        gl_Position = projectionMatrix * ecPosition;
    }
    </script>


    <script id="myFragmentShader" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 vNormal;
    in vec3 vPos;
    in vec3 vLocalPos;
    
    out vec4 fragmentColor;

    uniform int uRenderMode;
    uniform float uTime;
    uniform bool uIsSun;

    struct LightData {
        vec3 Position; // View Space Position of Light
        vec3 La; vec3 Ld; vec3 Ls;
    };
    uniform LightData Light;

    struct MaterialData {
        vec3 Ka; vec3 Kd; vec3 Ks; float alpha;
    };
    uniform MaterialData Material;

    
    vec3 calculatePhong(vec3 N, vec3 L, vec3 V, vec3 albedo) {
        vec3 ambient = Material.Ka * Light.La; // Could use albedo for ambient too
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);
        
        float dist = length(Light.Position - vPos);
        float attenuation = 1.0 / (0.1 + 0.01 * dist + 0.02 * dist * dist);

        float NdotL = max(0.0, dot(N, L));
        if (NdotL > 0.0) {
            vec3 R = reflect(-L, N);
            float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
            diffuse = NdotL * (Light.Ld * albedo); // Use albedo here
            specular = RdotV * (Light.Ls * Material.Ks);
        }
        return ambient + (diffuse + specular) * attenuation;
    }

    // --- Noise Functions ---
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    float simpleNoise(vec3 x) {
        vec3 p = floor(x);
        vec3 f = fract(x);
        f = f * f * (3.0 - 2.0 * f);
        float n = p.x + p.y * 57.0 + 113.0 * p.z;
        return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                       mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                   mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                       mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
    }

    vec3 getSunColor(vec3 pos) {
        vec3 c1 = vec3(1.0, 0.5, 0.0); 
        vec3 c2 = vec3(1.0, 0.9, 0.1); 
        float n = sin(pos.x * 20.0 + uTime) * sin(pos.y * 20.0 + uTime * 2.1) * sin(pos.z * 20.0 + uTime * 0.7);
        n = n * 0.5 + 0.5;
        float spot = smoothstep(0.7, 1.0, n);
        vec3 finalColor = mix(c1, c2, n);
        finalColor += vec3(1.0, 1.0, 0.8) * spot;
        return finalColor;
    }

    vec3 getEarthColor(vec3 pos) {
        // Noise for continents
        float n = simpleNoise(pos * 2.0); // Scale 2.0
        
        // Threshold for water/land
        // Ocean (Blue) vs Land (Green/Brown)
        vec3 ocean = vec3(0.0, 0.2, 0.8);
        vec3 land = vec3(0.1, 0.6, 0.2); // Green
        vec3 mountain = vec3(0.4, 0.3, 0.2); // Brown
        
        if (n < 0.5) {
            return ocean;
        } else if (n < 0.7) {
            return land;
        } else {
            return mountain;
        }
    }

    vec3 getMoonColor(vec3 pos) {
        float n = simpleNoise(pos * 5.0); // More frequent noise for craters
        float craters = smoothstep(0.4, 0.6, n);
        vec3 baseDate = vec3(0.5, 0.5, 0.5); // Grey
        vec3 dark = vec3(0.3, 0.3, 0.3);
        return mix(baseDate, dark, craters);
    }
    
    uniform int uTextureType; // 0=Solid, 1=Earth, 2=Moon
    uniform vec3 uBlockerPos;      // Position of blocking sphere (View Space)
    uniform float uBlockerRadius;  // Radius of blocking sphere

    // 0.0 = Sombra total, 1.0 = Luz total
    float calculateShadow(vec3 fragPos, vec3 lightPos) {
        if (uBlockerRadius <= 0.0) return 1.0; // No blocker

        vec3 L_vec = uBlockerPos - lightPos; // Vector de Luz a Centro Bloqueador
        vec3 D = normalize(fragPos - lightPos); // Dirección del Rayo de Luz
        
        float tca = dot(L_vec, D);
        if (tca < 0.0) return 1.0; // Bloqueador detrás de la luz

        float d2 = dot(L_vec, L_vec) - tca * tca;
        float r2 = uBlockerRadius * uBlockerRadius;
        
        if (d2 > r2) return 1.0; // Rayo pasa fuera de la esfera bloqueadora

        float thc = sqrt(r2 - d2);
        float t0 = tca - thc; // Primera intersección
        
        float fragDist = length(fragPos - lightPos);
        
        // Si la intersección es válida (positiva) y está ANTES que el fragmento (con margen)
        if (t0 > 0.1 && t0 < (fragDist - 0.1)) {
            return 0.0; // En Sombra
        }
        
        return 1.0; // Iluminado
    }

    void main() {
        if (uIsSun) {
            fragmentColor = vec4(getSunColor(vLocalPos), 1.0);
        } else {
            vec3 albedo;
            if (uTextureType == 1) {
                albedo = getEarthColor(vLocalPos);
            } else if (uTextureType == 2) {
                albedo = getMoonColor(vLocalPos);
            } else {
                albedo = Material.Kd; 
            }
            
            vec3 N = normalize(vNormal);
            vec3 L = normalize(Light.Position - vPos);
            vec3 V = normalize(-vPos);
            
            // Calcular factor de sombra
            float shadow = calculateShadow(vPos, Light.Position);
            
            // Phong con sombra
            vec3 ambient = Material.Ka * Light.La; // Ambiente siempre existe
            vec3 diffuse = vec3(0.0);
            vec3 specular = vec3(0.0);
            
            float dist = length(Light.Position - vPos);
            float attenuation = 1.0 / (0.1 + 0.01 * dist + 0.02 * dist * dist);
            
            // Solo aplicamos Diffuse/Specular si NO hay sombra
            // O multiplicamos por shadow (0.0 o 1.0)
            
            float NdotL = max(0.0, dot(N, L));
            if (NdotL > 0.0) {
                vec3 R = reflect(-L, N);
                float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
                diffuse = NdotL * (Light.Ld * albedo) * shadow; // Shadow here
                specular = RdotV * (Light.Ls * Material.Ks) * shadow; // Shadow here
            }
            
            vec3 finalColor = ambient + (diffuse + specular) * attenuation;
            fragmentColor = vec4(finalColor, 1.0);
        }
    }
    </script>
</head>

<body>



    <canvas id="myCanvas" width="800" height="600">
        Tu navegador no soporta HTML5
    </canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>

    <script src="SistemaSolarScript.js"></script>
</body>

</html>