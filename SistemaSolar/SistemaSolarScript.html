<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Selector de Shaders: Toon vs Niebla</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }

        canvas {
            border: 2px solid #333;
            background-color: #262626;
        }

        .controls {
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            margin: 0 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2E7D32;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Estilos para las etiquetas de los planetas */
        #labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* No interfiere con el ratón */
            overflow: hidden;
            z-index: 10;
        }

        .planet-label {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px black;
            transform: translate(-50%, -100%);
            white-space: nowrap;
        }

        #container {
            position: relative;
            display: inline-block;
        }
    </style>


    <script id="myVertexShader" type="x-shader/x-vertex">#version 300 es
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;

    in vec3 VertexPosition;
    in vec3 VertexNormal;

    out vec3 vNormal;
    out vec3 vPos;       // View Space Position (for lighting)
    out vec3 vLocalPos;  // Object Space Position (for texturing)

    void main() {
        vNormal = normalize(normalMatrix * VertexNormal);
        vec4 ecPosition = modelViewMatrix * vec4(VertexPosition, 1.0);
        vPos = vec3(ecPosition);
        vLocalPos = VertexPosition; // Pass original position
        gl_Position = projectionMatrix * ecPosition;
    }
    </script>


    <script id="myFragmentShader" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 vNormal;
    in vec3 vPos;
    in vec3 vLocalPos;
    
    out vec4 fragmentColor;

    uniform int uRenderMode;
    uniform float uTime;
    uniform bool uIsSun;

    struct LightData {
        vec3 Position; // View Space Position of Light
        vec3 La; vec3 Ld; vec3 Ls;
    };
    uniform LightData Light;

    struct MaterialData {
        vec3 Ka; vec3 Kd; vec3 Ks; float alpha;
    };
    uniform MaterialData Material;

    
    vec3 calculatePhong(vec3 N, vec3 L, vec3 V, vec3 albedo) {
        vec3 ambient = Material.Ka * Light.La; // Could use albedo for ambient too
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);
        
        float dist = length(Light.Position - vPos);
        float attenuation = 1.0 / (0.1 + 0.01 * dist + 0.02 * dist * dist);

        float NdotL = max(0.0, dot(N, L));
        if (NdotL > 0.0) {
            vec3 R = reflect(-L, N);
            float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
            diffuse = NdotL * (Light.Ld * albedo); // Use albedo here
            specular = RdotV * (Light.Ls * Material.Ks);
        }
        return ambient + (diffuse + specular) * attenuation;
    }

    // --- Noise Functions ---
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    float simpleNoise(vec3 x) {
        vec3 p = floor(x);
        vec3 f = fract(x);
        f = f * f * (3.0 - 2.0 * f);
        float n = p.x + p.y * 57.0 + 113.0 * p.z;
        return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                       mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                   mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                       mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
    }

    vec3 getSunColor(vec3 pos) {
        vec3 c1 = vec3(1.0, 0.5, 0.0); 
        vec3 c2 = vec3(1.0, 0.9, 0.1); 
        float n = sin(pos.x * 20.0 + uTime) * sin(pos.y * 20.0 + uTime * 2.1) * sin(pos.z * 20.0 + uTime * 0.7);
        n = n * 0.5 + 0.5;
        float spot = smoothstep(0.7, 1.0, n);
        vec3 finalColor = mix(c1, c2, n);
        finalColor += vec3(1.0, 1.0, 0.8) * spot;
        return finalColor;
    }

    vec3 getEarthColor(vec3 pos) {
        // Noise for continents
        float n = simpleNoise(pos * 2.0); // Scale 2.0
        
        // Threshold for water/land
        // Ocean (Blue) vs Land (Green/Brown)
        vec3 ocean = vec3(0.0, 0.2, 0.8);
        vec3 land = vec3(0.1, 0.6, 0.2); // Green
        vec3 mountain = vec3(0.4, 0.3, 0.2); // Brown
        
        if (n < 0.5) {
            return ocean;
        } else if (n < 0.7) {
            return land;
        } else {
            return mountain;
        }
    }

    vec3 getMoonColor(vec3 pos) {
        float n = simpleNoise(pos * 5.0); // More frequent noise for craters
        float craters = smoothstep(0.4, 0.6, n);
        vec3 baseDate = vec3(0.5, 0.5, 0.5); // Grey
        vec3 dark = vec3(0.3, 0.3, 0.3);
        return mix(baseDate, dark, craters);
    }
    
    vec3 getMercuryColor(vec3 pos) {
        return getMoonColor(pos) * 1.2; // Similar a la luna pero más brillante/diferente tono
    }

    vec3 getVenusColor(vec3 pos) {
        float n = simpleNoise(pos * 3.0);
        vec3 c1 = vec3(1.0, 0.9, 0.6); // Amarillo pálido
        vec3 c2 = vec3(0.9, 0.6, 0.2); // Naranja
        return mix(c1, c2, n);
    }

    vec3 getMarsColor(vec3 pos) {
        float n = simpleNoise(pos * 4.0);
        vec3 c1 = vec3(0.8, 0.3, 0.1); // Rojo óxido
        vec3 c2 = vec3(0.6, 0.2, 0.1); // Rojo oscuro
        return mix(c1, c2, smoothstep(0.3, 0.7, n));
    }

    vec3 getJupiterColor(vec3 pos) {
        // Bandas horizontales basadas en Y
        float bands = sin(pos.y * 10.0 + simpleNoise(pos*3.0)*2.0); 
        vec3 c1 = vec3(0.9, 0.8, 0.7); // Crema
        vec3 c2 = vec3(0.8, 0.5, 0.4); // Marrón rojizo
        return mix(c1, c2, bands * 0.5 + 0.5);
    }
    
    vec3 getSaturnColor(vec3 pos) {
        float bands = sin(pos.y * 8.0);
        vec3 c1 = vec3(0.9, 0.85, 0.6); // Dorado pálido
        vec3 c2 = vec3(0.8, 0.7, 0.5); // Beige
        return mix(c1, c2, bands * 0.5 + 0.5);
    }

    vec3 getUranusColor(vec3 pos) {
        return vec3(0.6, 0.8, 0.9) * (0.9 + 0.1 * simpleNoise(pos * 5.0)); // Featureless Cyan
    }

    vec3 getNeptuneColor(vec3 pos) {
        return vec3(0.2, 0.3, 0.8) * (0.8 + 0.2 * simpleNoise(pos * 5.0)); // Deep Blue
    }

    vec3 getRingColor(vec3 pos) {
        // Franjas de polvo/hielo basadas en la distancia radial
        float r = length(pos.xz);
        float bands = sin(r * 80.0) * 0.5 + 0.5;
        vec3 c1 = vec3(0.7, 0.6, 0.4);
        vec3 c2 = vec3(0.4, 0.3, 0.2);
        return mix(c1, c2, bands);
    }

    vec3 getStarsColor(vec3 pos) {
        float n = hash(pos.x * 123.4 + pos.y * 567.8 + pos.z * 910.1);
        if (n > 0.9997) return vec3(1.0, 1.0, 1.0);
        return vec3(0.0, 0.0, 0.0);
    }

    uniform int uTextureType; 
    // 0=Solid, 1=Earth, 2=Moon, 3=Mercury, 4=Venus, 5=Mars, 6=Jupiter, 7=Saturn, 8=Uranus, 9=Neptune, 10=Stars, 11=Rings

    uniform vec3 uBlockerPos;
    uniform float uBlockerRadius;

    // 0.0 = Sombra total, 1.0 = Luz total
    float calculateShadow(vec3 fragPos, vec3 lightPos) {
        if (uBlockerRadius <= 0.0) return 1.0; 

        vec3 L_vec = uBlockerPos - lightPos;
        vec3 D = normalize(fragPos - lightPos);
        
        float tca = dot(L_vec, D);
        if (tca < 0.0) return 1.0; 

        float d2 = dot(L_vec, L_vec) - tca * tca;
        float r2 = uBlockerRadius * uBlockerRadius;
        
        if (d2 > r2) return 1.0; 

        float thc = sqrt(r2 - d2);
        float t0 = tca - thc; 
        
        float fragDist = length(fragPos - lightPos);
        
        if (t0 > 0.1 && t0 < (fragDist - 0.1)) {
            return 0.0; 
        }
        
        return 1.0; 
    }

    void main() {
        if (uIsSun) {
            fragmentColor = vec4(getSunColor(vLocalPos), 1.0);
        } else {
            vec3 albedo;
            // Selección de textura planetaria
            if (uTextureType == 1) albedo = getEarthColor(vLocalPos);
            else if (uTextureType == 2) albedo = getMoonColor(vLocalPos);
            else if (uTextureType == 3) albedo = getMercuryColor(vLocalPos);
            else if (uTextureType == 4) albedo = getVenusColor(vLocalPos);
            else if (uTextureType == 5) albedo = getMarsColor(vLocalPos);
            else if (uTextureType == 6) albedo = getJupiterColor(vLocalPos);
            else if (uTextureType == 7) albedo = getSaturnColor(vLocalPos);
            else if (uTextureType == 8) albedo = getUranusColor(vLocalPos);
            else if (uTextureType == 9) albedo = getNeptuneColor(vLocalPos);
            else if (uTextureType == 11) albedo = getRingColor(vLocalPos);
            else if (uTextureType == 10) {
                fragmentColor = vec4(getStarsColor(vLocalPos), 1.0);
                return;
            }
            else if (uTextureType == 12) {
                fragmentColor = vec4(Material.Kd, 1.0);
                return;
            }
            else albedo = Material.Kd; // Fallback
            
            vec3 N = normalize(vNormal);
            vec3 L = normalize(Light.Position - vPos);
            vec3 V = normalize(-vPos);
            
            // Calcular factor de sombra
            float shadow = calculateShadow(vPos, Light.Position);
            
            vec3 ambient = Material.Ka * Light.La; 
            vec3 diffuse = vec3(0.0);
            vec3 specular = vec3(0.0);
            
            float dist = length(Light.Position - vPos);
            float attenuation = 1.0 / (1.0 + 0.01 * dist + 0.002 * dist * dist);
            
            float NdotL = max(0.0, dot(N, L));
            if (NdotL > 0.0) {
                vec3 R = reflect(-L, N);
                float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
                diffuse = NdotL * (Light.Ld * albedo) * shadow; 
                specular = RdotV * (Light.Ls * Material.Ks) * shadow; 
            }
            
            vec3 finalColor = ambient + (diffuse + specular) * attenuation;
            
            // Tonemapping (Reinhard) para evitar que se quemen los colores cerca del sol
            finalColor = finalColor / (finalColor + vec3(1.0));
            
            // Corrección Gamma básica
            finalColor = pow(finalColor, vec3(1.0 / 2.2));
            
            fragmentColor = vec4(finalColor, 1.0);
        }
    }
    </script>
</head>

<body>



    <div id="container">
        <canvas id="myCanvas" width="800" height="600">
            Tu navegador no soporta HTML5
        </canvas>
        <div id="labels"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>

    <script src="SistemaSolarScript.js"></script>
</body>

</html>