<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Selector de Shaders: Toon vs Niebla</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }

        canvas {
            border: 2px solid #333;
            background-color: #262626;
        }

        .controls {
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            margin: 0 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2E7D32;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        
        #labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            
            overflow: hidden;
            z-index: 10;
        }

        .planet-label {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px black;
            transform: translate(-50%, -100%);
            white-space: nowrap;
        }

        #container {
            position: relative;
            display: inline-block;
        }
    </style>


    <script id="myVertexShader" type="x-shader/x-vertex">#version 300 es
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;

    in vec3 VertexPosition;
    in vec3 VertexNormal;

    out vec3 vNormal;
    out vec3 vPos;       
    out vec3 vLocalPos;  

    void main() {
        vNormal = normalize(normalMatrix * VertexNormal);
        vec4 ecPosition = modelViewMatrix * vec4(VertexPosition, 1.0);
        vPos = vec3(ecPosition);
        vLocalPos = VertexPosition; 
        gl_Position = projectionMatrix * ecPosition;
    }
    </script>


    <script id="myFragmentShader" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 vNormal;
    in vec3 vPos;
    in vec3 vLocalPos;
    
    out vec4 fragmentColor;

    uniform int uRenderMode;
    uniform float uTime;
    uniform bool uIsSun;

    struct LightData {
        vec3 Position; 
        vec3 La; vec3 Ld; vec3 Ls;
    };
    uniform LightData Light;

    struct MaterialData {
        vec3 Ka; vec3 Kd; vec3 Ks; float alpha;
    };
    uniform MaterialData Material;

    
    vec3 calculatePhong(vec3 N, vec3 L, vec3 V, vec3 albedo) {
        vec3 ambient = Material.Ka * Light.La; 
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);
        
        float dist = length(Light.Position - vPos);
        float attenuation = 1.0 / (0.1 + 0.01 * dist + 0.02 * dist * dist);

        float NdotL = max(0.0, dot(N, L));
        if (NdotL > 0.0) {
            vec3 R = reflect(-L, N);
            float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
            diffuse = NdotL * (Light.Ld * albedo); 
            specular = RdotV * (Light.Ls * Material.Ks);
        }
        return ambient + (diffuse + specular) * attenuation;
    }

    
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    
    float noise(vec3 x) {
        vec3 p = floor(x);
        vec3 f = fract(x);
        f = f * f * (3.0 - 2.0 * f);
        float n = p.x + p.y * 57.0 + 113.0 * p.z;
        return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                       mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                   mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                       mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
    }
    
    
    float fbm(vec3 p) {
        float f = 0.0;
        float w = 0.5;
        for (int i = 0; i < 5; i++) {
            f += w * noise(p);
            p = p * 2.02; 
            w *= 0.5;
        }
        return f;
    }
    
    
    float simpleNoise(vec3 x) { return noise(x); }

    vec3 getSunColor(vec3 pos) {
        
        float t = uTime * 0.2;
        
        
        vec3 p = pos * 3.0; 
        float n = fbm(p + vec3(0.0, t, 0.0));
        
        
        float n2 = fbm(pos * 6.0 - vec3(t, 0.0, t*0.5));
        
        
        float heat = n * 0.5 + n2 * 0.5;
        
        
        
        vec3 colorDark = vec3(0.7, 0.1, 0.0);   
        vec3 colorBase = vec3(1.0, 0.5, 0.0);   
        vec3 colorBright = vec3(1.0, 0.9, 0.2); 
        vec3 colorHot = vec3(1.0, 1.0, 0.9);    
        
        vec3 finalColor = mix(colorDark, colorBase, smoothstep(0.2, 0.5, heat));
        finalColor = mix(finalColor, colorBright, smoothstep(0.5, 0.8, heat));
        finalColor = mix(finalColor, colorHot, smoothstep(0.8, 1.0, heat));
        
        
        
        
        
        
        return finalColor * 1.5; 
    }

    vec3 getEarthColor(vec3 pos) {
        
        float n = fbm(pos * 2.0); 

        
        float lat = abs(pos.y); 

        
        if (n < 0.5) {
            
            
            float depth = n / 0.5; 
            
            
            
            vec3 q = pos * 15.0 + vec3(uTime * 0.2, 0.0, uTime * 0.1);
            float w = fbm(q);
            float w2 = fbm(pos * 30.0 - vec3(uTime * 0.3, 0.0, uTime * 0.3)); 
            
            float waveMix = w * 0.6 + w2 * 0.4;
            
            
            vec3 colDeep = vec3(0.01, 0.03, 0.20); 
            vec3 colMid  = vec3(0.02, 0.15, 0.45);
            vec3 colShore = vec3(0.0, 0.5, 0.6);
            
            
            vec3 water = mix(colDeep, colMid, smoothstep(0.4, 0.8, depth));
            water = mix(water, colShore, smoothstep(0.8, 1.0, depth));
            
            
            
            float foamMask = smoothstep(0.65, 0.8, waveMix);            
            float shoreFoam = smoothstep(0.9, 1.0, depth) * 0.5; 
            
            vec3 foamColor = vec3(0.9);
            water += foamColor * (foamMask * 0.3 + shoreFoam);
            
            
            water += vec3(0.05) * waveMix;
            
            return water;
        }

        
        
        float h = (n - 0.5) * 2.0;
        
        
        float biomeNoise = fbm(pos * 4.0);
        float fineGrain = fbm(pos * 60.0); 
        
        vec3 col;
        
        
        vec3 sand = vec3(0.85, 0.78, 0.60);
        vec3 forestDark = vec3(0.02, 0.18, 0.04); 
        vec3 forestBright = vec3(0.05, 0.35, 0.05); 
        vec3 grass = vec3(0.25, 0.45, 0.15); 
        vec3 rock = vec3(0.35, 0.32, 0.30);
        vec3 snow = vec3(0.98, 0.98, 1.0);
        
        if (lat > 0.85) {
            
            col = snow;
             
            float ice = smoothstep(0.4, 0.6, fineGrain);
            col = mix(col, vec3(0.85, 0.9, 1.0), ice);
        } else {
            
            if (h < 0.04) {
                 col = sand;
            } else {
                 
                 
                 float moisture = (1.0 - lat) * 0.6 + biomeNoise * 0.4;
                 
                 vec3 biome;
                 
                 if (h > 0.7) {
                     
                     biome = mix(rock, snow, smoothstep(0.7, 0.9, h));
                 } else {
                     
                     if (moisture > 0.6) {
                         
                         biome = mix(forestDark, forestBright, fineGrain);
                     } else if (moisture > 0.3) {
                         
                         vec3 base = grass;
                         
                         if (fineGrain > 0.6) base = forestDark;
                         biome = base;
                     } else {
                         
                         biome = mix(vec3(0.5, 0.4, 0.2), grass, fineGrain);
                     }
                 }
                 
                 col = biome;
                 
                 
                 
                 col *= (0.8 + 0.4 * smoothstep(0.2, 0.8, fineGrain));
            }
        }
        
        return col;
    }

    vec3 getMoonColor(vec3 pos) {
        
        float n = fbm(pos * 2.5);
        
        
        float detail = fbm(pos * 12.0);
        
        
        float c = noise(pos * 8.0);
        c = abs(c - 0.5) * 2.0; 
        c = smoothstep(0.2, 0.8, c); 

        vec3 darkMare = vec3(0.25, 0.25, 0.28); 
        vec3 lightHigh = vec3(0.7, 0.7, 0.72);  
        
        vec3 base = mix(darkMare, lightHigh, smoothstep(0.4, 0.55, n));
        
        
        base *= (0.8 + 0.4 * detail); 
        base *= (0.5 + 0.5 * c);      
        
        return base;
    }
    
    vec3 getMercuryColor(vec3 pos) {
        
        vec3 moon = getMoonColor(pos);
        return moon * vec3(0.9, 0.8, 0.7) * 1.1; 
    }

    vec3 getVenusColor(vec3 pos) {
        
        
        float n = fbm(pos * 4.0 + vec3(uTime * 0.1, 0.0, 0.0)); 
        
        vec3 cream = vec3(1.0, 0.95, 0.8);
        vec3 orange = vec3(0.8, 0.5, 0.2);
        
        return mix(orange, cream, n);
    }

    vec3 getMarsColor(vec3 pos) {
        
        float ice = smoothstep(0.8, 0.95, abs(pos.y));
        
        
        float n = fbm(pos * 3.5);
        float rock = smoothstep(0.3, 0.6, n);
        
        
        vec3 rust = vec3(0.8, 0.35, 0.15);  
        vec3 darkRock = vec3(0.35, 0.15, 0.1); 
        vec3 iceColor = vec3(0.95, 0.95, 0.98);
        
        vec3 surface = mix(rust, darkRock, rock);
        
        
        
        
        return mix(surface, iceColor, ice);
    }

    vec3 getJupiterColor(vec3 pos) {
        
        
        float turb = fbm(pos * 6.0 + vec3(uTime * 0.2, 0.0, 0.0));
        float y = pos.y * 6.0 + turb * 0.5;
        
        float bands = sin(y);
        
        
        
        
        
        float spotDist = length(pos.xy - vec2(0.4, -0.2)); 
        float spot = smoothstep(0.4, 0.25, spotDist);
        
        
        vec3 zone = vec3(0.95, 0.9, 0.8); 
        vec3 belt = vec3(0.6, 0.35, 0.2); 
        vec3 redSpotColor = vec3(0.7, 0.2, 0.1);
        
        vec3 col = mix(belt, zone, bands * 0.5 + 0.5);
        
        
        if (spot > 0.0) {
            
            float spotTurb = fbm(pos * 10.0 + uTime * 0.5);
            col = mix(col, redSpotColor * (0.8 + 0.2*spotTurb), spot);
        }
        
        return col;
    }
    
    vec3 getSaturnColor(vec3 pos) {
        
        float turb = fbm(pos * 8.0) * 0.1; 
        float bands = sin(pos.y * 12.0 + turb);
        
        vec3 gold = vec3(0.85, 0.75, 0.5);
        vec3 beige = vec3(0.75, 0.65, 0.45);
        vec3 greyish = vec3(0.6, 0.6, 0.5); 
        
        vec3 col = mix(beige, gold, bands * 0.5 + 0.5);
        
        
        if (abs(pos.y) > 0.9) {
            col = mix(col, greyish, 0.5);
        }
        
        return col;
    }

    vec3 getUranusColor(vec3 pos) {
        
        
        float band = smoothstep(-1.0, 1.0, sin(pos.y * 10.0));
        
        vec3 cyan = vec3(0.55, 0.8, 0.85);
        vec3 pale = vec3(0.65, 0.85, 0.9);
        
        
        return mix(cyan, pale, band * 0.3);
    }

    vec3 getNeptuneColor(vec3 pos) {
        
        float turb = fbm(pos * 5.0 + vec3(uTime*1.5, 0.0, 0.0)); 
        
        vec3 brightBlue = vec3(0.2, 0.3, 0.9);
        vec3 deepBlue = vec3(0.1, 0.15, 0.6);
        vec3 whiteCloud = vec3(0.9, 0.95, 1.0);
        
        
        vec3 col = mix(deepBlue, brightBlue, 0.5 + 0.5 * sin(pos.y * 4.0 + turb));
        
        
        float streak = smoothstep(0.6, 0.8, fbm(pos * vec3(2.0, 20.0, 2.0) + vec3(uTime*4.0, 0.0, 0.0)));
        col = mix(col, whiteCloud, streak * 0.6);
        
        return col;
    }

    vec3 getRingColor(vec3 pos) {
        
        float r = length(pos.xz);
        
        
        float grooves = sin(r * 200.0);
        
        
        
        float cassini = smoothstep(0.02, 0.03, abs(r - 1.8)); 
        
        
        vec3 inner = vec3(0.6, 0.5, 0.4);
        vec3 outer = vec3(0.55, 0.5, 0.4);
        
        vec3 dust = mix(inner, outer, r - 1.3);
        
        
        dust *= (0.8 + 0.2 * grooves);
        
        
        
        if (cassini < 0.1) return vec3(0.05); 
        
        return dust;
    }

    vec3 getStarsColor(vec3 pos) {
        float n = hash(pos.x * 123.4 + pos.y * 567.8 + pos.z * 910.1);
        if (n > 0.9997) return vec3(1.0, 1.0, 1.0);
        return vec3(0.0, 0.0, 0.0);
    }

    uniform int uTextureType; 
    

    uniform vec3 uBlockerPos;
    uniform float uBlockerRadius;

    
    float calculateShadow(vec3 fragPos, vec3 lightPos) {
        if (uBlockerRadius <= 0.0) return 1.0; 

        vec3 L_vec = uBlockerPos - lightPos;
        vec3 D = normalize(fragPos - lightPos);
        
        float tca = dot(L_vec, D);
        if (tca < 0.0) return 1.0; 

        float d2 = dot(L_vec, L_vec) - tca * tca;
        float r2 = uBlockerRadius * uBlockerRadius;
        
        if (d2 > r2) return 1.0; 

        float thc = sqrt(r2 - d2);
        float t0 = tca - thc; 
        
        float fragDist = length(fragPos - lightPos);
        
        if (t0 > 0.1 && t0 < (fragDist - 0.1)) {
            return 0.0; 
        }
        
        return 1.0; 
    }

    void main() {
        if (uIsSun) {
            fragmentColor = vec4(getSunColor(vLocalPos), 1.0);
        } else {
            vec3 albedo;
            
            if (uTextureType == 1) albedo = getEarthColor(vLocalPos);
            else if (uTextureType == 2) albedo = getMoonColor(vLocalPos);
            else if (uTextureType == 3) albedo = getMercuryColor(vLocalPos);
            else if (uTextureType == 4) albedo = getVenusColor(vLocalPos);
            else if (uTextureType == 5) albedo = getMarsColor(vLocalPos);
            else if (uTextureType == 6) albedo = getJupiterColor(vLocalPos);
            else if (uTextureType == 7) albedo = getSaturnColor(vLocalPos);
            else if (uTextureType == 8) albedo = getUranusColor(vLocalPos);
            else if (uTextureType == 9) albedo = getNeptuneColor(vLocalPos);
            else if (uTextureType == 11) albedo = getRingColor(vLocalPos);
            else if (uTextureType == 10) {
                fragmentColor = vec4(getStarsColor(vLocalPos), 1.0);
                return;
            }
            else if (uTextureType == 12) {
                fragmentColor = vec4(Material.Kd, 1.0);
                return;
            }
            else albedo = Material.Kd; 
            
            vec3 N = normalize(vNormal);
            vec3 L = normalize(Light.Position - vPos);
            vec3 V = normalize(-vPos);
            
            
            float shadow = calculateShadow(vPos, Light.Position);
            
            vec3 ambient = Material.Ka * Light.La; 
            vec3 diffuse = vec3(0.0);
            vec3 specular = vec3(0.0);
            
            float dist = length(Light.Position - vPos);
            float attenuation = 1.0 / (1.0 + 0.01 * dist + 0.002 * dist * dist);
            
            float NdotL = max(0.0, dot(N, L));
            if (NdotL > 0.0) {
                vec3 R = reflect(-L, N);
                float RdotV = pow(max(0.0, dot(R, V)), Material.alpha);
                diffuse = NdotL * (Light.Ld * albedo) * shadow; 
                specular = RdotV * (Light.Ls * Material.Ks) * shadow; 
            }
            
            vec3 finalColor = ambient + (diffuse + specular) * attenuation;
            
            
            finalColor = finalColor / (finalColor + vec3(1.0));
            
            
            finalColor = pow(finalColor, vec3(1.0 / 2.2));
            
            fragmentColor = vec4(finalColor, 1.0);
        }
    }
    </script>
</head>

<body>



    <div id="container">
        <canvas id="myCanvas" width="800" height="600">
            Tu navegador no soporta HTML5
        </canvas>
        <div id="labels"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>

    <script src="SistemaSolarScript.js"></script>
</body>

</html>